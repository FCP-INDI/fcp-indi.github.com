
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>CPAC.network_centrality.resting_state_centrality &#8212; C-PAC 1.3.0 Beta documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">C-PAC 1.3.0 Beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for CPAC.network_centrality.resting_state_centrality</h1><div class="highlight"><pre>
<span></span><span class="c1"># CPAC/network_centrality/resting_state_centrality.py</span>
<span class="c1">#</span>
<span class="c1">#</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This module contains all of the network centrality workflow functions</span>
<span class="sd">used in C-PAC</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># Function to create the network centrality workflow</span>
<div class="viewcode-block" id="create_resting_state_graphs"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.create_resting_state_graphs">[docs]</a><span class="k">def</span> <span class="nf">create_resting_state_graphs</span><span class="p">(</span><span class="n">wf_name</span><span class="o">=</span><span class="s1">&#39;resting_state_graph&#39;</span><span class="p">,</span> 
                                <span class="n">allocated_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Workflow to calculate degree and eigenvector centrality as well as </span>
<span class="sd">    local functional connectivity density (lfcd) measures for the </span>
<span class="sd">    resting state data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    generate_graph : boolean</span>
<span class="sd">        when true the workflow plots the adjacency matrix graph </span>
<span class="sd">        and converts the adjacency matrix into compress sparse </span>
<span class="sd">        matrix and stores it in a .mat file. By default its False</span>
<span class="sd">    wf_name : string</span>
<span class="sd">        name of the workflow</span>
<span class="sd">        </span>
<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    wf : workflow object</span>
<span class="sd">        resting state graph workflow object</span>
<span class="sd">          </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">    `Source &lt;https://github.com/FCP-INDI/C-PAC/blob/master/CPAC/network_centrality/resting_state_centrality.py&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Workflow Inputs::</span>
<span class="sd">    </span>
<span class="sd">        inputspec.subject: string (nifti file)</span>
<span class="sd">            path to resting state input data for which centrality measure is to be calculated</span>
<span class="sd">            </span>
<span class="sd">        inputspec.template : string (existing nifti file)</span>
<span class="sd">            path to mask/parcellation unit </span>
<span class="sd">        </span>
<span class="sd">        inputspec.method_option: string (int)</span>
<span class="sd">            0 for degree centrality, 1 for eigenvector centrality, 2 for lFCD</span>
<span class="sd">        </span>
<span class="sd">        inputspec.threshold: string (float)</span>
<span class="sd">            pvalue/sparsity_threshold/threshold value</span>
<span class="sd">        </span>
<span class="sd">        inputspec.threshold_option: string (int)</span>
<span class="sd">            threshold options:  0 for probability p_value, 1 for sparsity threshold, any other for threshold value</span>

<span class="sd">        centrality_options.method_options : string (list of boolean)</span>
<span class="sd">            list of two booleans for Degree and Eigenvector centrality method options respectively</span>
<span class="sd">        </span>
<span class="sd">    Workflow Outputs::</span>
<span class="sd">    </span>
<span class="sd">        outputspec.centrality_outputs : string (list of nifti files)</span>
<span class="sd">            path to list of centrality outputs for binarized or/and weighted and</span>
<span class="sd">            degree or/and eigen_vector </span>
<span class="sd">        </span>
<span class="sd">        outputspec.threshold_matrix : string (numpy file)</span>
<span class="sd">            path to file containing thresholded correlation matrix</span>
<span class="sd">        </span>
<span class="sd">        outputspec.correlation_matrix : string (numpy file)</span>
<span class="sd">            path to file containing correlation matrix</span>
<span class="sd">        </span>
<span class="sd">        outputspec.graph_outputs : string (mat and png files)</span>
<span class="sd">            path to matlab compatible sparse adjacency matrix files </span>
<span class="sd">            and adjacency graph images </span>
<span class="sd">    </span>
<span class="sd">    Order of commands:</span>
<span class="sd">    </span>
<span class="sd">    - load the data and template, based on template type (parcellation unit ar mask)</span>
<span class="sd">      extract timeseries</span>
<span class="sd">    </span>
<span class="sd">    - Calculate the correlation matrix for the image data for each voxel in the mask or node</span>
<span class="sd">      in the parcellation unit</span>
<span class="sd">    </span>
<span class="sd">    - Based on threshold option (p_value or sparsity_threshold), calculate the threshold value</span>
<span class="sd">    </span>
<span class="sd">    - Threshold the correlation matrix</span>
<span class="sd">     </span>
<span class="sd">    - Based on weight options for edges in the network (binarize or weighted), calculate Degree </span>
<span class="sd">      or Vector Based centrality measures</span>
<span class="sd">     </span>
<span class="sd">    </span>
<span class="sd">    High Level Workflow Graph:</span>
<span class="sd">    </span>
<span class="sd">    .. image:: ../images/resting_state_centrality.dot.png</span>
<span class="sd">       :width: 1000</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Detailed Workflow Graph:</span>
<span class="sd">    </span>
<span class="sd">    .. image:: ../images/resting_state_centrality_detailed.dot.png</span>
<span class="sd">       :width: 1000</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import resting_state_centrality as graph</span>
<span class="sd">    &gt;&gt;&gt; wflow = graph.create_resting_state_graphs()</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.centrality_options.method_options=[True, True]</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.datafile = &#39;/home/work/data/rest_mc_MNI_TR_3mm.nii.gz&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.template = &#39;/home/work/data/mask_3mm.nii.gz&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.threshold_option = &#39;Correlation threshold&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.threshold = 0.0744</span>
<span class="sd">    &gt;&gt;&gt; wflow.base_dir = &#39;graph_working_directory&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.run()</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Import packages</span>
    <span class="kn">import</span> <span class="nn">nipype.pipeline.engine</span> <span class="k">as</span> <span class="nn">pe</span>
    <span class="kn">import</span> <span class="nn">nipype.interfaces.utility</span> <span class="k">as</span> <span class="nn">util</span>

    <span class="c1"># Init variables</span>
    <span class="c1"># Instantiate workflow with input name</span>
    <span class="n">wf</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">wf_name</span><span class="p">)</span>
    
    <span class="c1"># Instantiate inputspec node</span>
    <span class="n">inputspec</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in_file&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;template&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;method_option&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;threshold_option&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;threshold&#39;</span><span class="p">]),</span>
                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;inputspec&#39;</span><span class="p">)</span>
    
    <span class="c1"># Instantiate calculate_centrality main function node</span>
    <span class="n">calculate_centrality</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">input_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in_file&#39;</span><span class="p">,</span>
                                                              <span class="s1">&#39;template&#39;</span><span class="p">,</span>
                                                              <span class="s1">&#39;method_option&#39;</span><span class="p">,</span>
                                                              <span class="s1">&#39;threshold_option&#39;</span><span class="p">,</span>
                                                              <span class="s1">&#39;threshold&#39;</span><span class="p">,</span>
                                                              <span class="s1">&#39;allocated_memory&#39;</span><span class="p">],</span>
                                                 <span class="n">output_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out_list&#39;</span><span class="p">],</span>
                                                 <span class="n">function</span><span class="o">=</span><span class="n">calc_centrality</span><span class="p">),</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;calculate_centrality&#39;</span><span class="p">)</span>

    <span class="c1"># Specify memory to interface for resource profiling</span>
    <span class="n">calculate_centrality</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">estimated_memory_gb</span> <span class="o">=</span> <span class="n">allocated_memory</span>

    <span class="c1"># Connect inputspec node to main function node</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s1">&#39;in_file&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;in_file&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s1">&#39;template&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;template&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s1">&#39;method_option&#39;</span><span class="p">,</span>
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;method_option&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s1">&#39;threshold_option&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;threshold_option&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s1">&#39;threshold&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;threshold&#39;</span><span class="p">)</span>

    <span class="c1"># Specify allocated memory for calculating block size in function</span>
    <span class="n">calculate_centrality</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">allocated_memory</span> <span class="o">=</span> <span class="n">allocated_memory</span>
    
    <span class="c1"># Instantiate outputspec node</span>
    <span class="n">outputspec</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;centrality_outputs&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;threshold_matrix&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;correlation_matrix&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;graph_outputs&#39;</span><span class="p">]),</span>
                         <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;outputspec&#39;</span><span class="p">)</span>
    
    <span class="c1"># Connect function node output list to outputspec node</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">calculate_centrality</span><span class="p">,</span> <span class="s1">&#39;out_list&#39;</span><span class="p">,</span>
               <span class="n">outputspec</span><span class="p">,</span> <span class="s1">&#39;centrality_outputs&#39;</span><span class="p">)</span>
    
    <span class="c1"># Return the connected workflow</span>
    <span class="k">return</span> <span class="n">wf</span></div>


<span class="c1"># Function to load in nifti files and extract info for centrality calculation</span>
<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to read data from datafile and mask/parcellation unit</span>
<span class="sd">    and store the mask data, timeseries, affine matrix, mask type</span>
<span class="sd">    and scans. The output of this method is used by all other nodes.</span>
<span class="sd">    </span>
<span class="sd">    Note that this function also will internally compute it&#39;s own </span>
<span class="sd">    brain mask by getting all voxels with non-zero variance in the</span>
<span class="sd">    timeseries.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datafile : string (nifti file)</span>
<span class="sd">        path to subject data file</span>
<span class="sd">    template : string (nifti file) or None (default: None)</span>
<span class="sd">        path to mask/parcellation unit</span>
<span class="sd">        if none, then will be mask with all 1s</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    timeseries_data : ndarray</span>
<span class="sd">        Masked timeseries of the input data. </span>
<span class="sd">    affine : ndarray</span>
<span class="sd">        Affine matrix of the input data</span>
<span class="sd">    final_mask : ndarray</span>
<span class="sd">        Mask/parcellation unit matrix</span>
<span class="sd">    template_type : string </span>
<span class="sd">        0 for mask, 1 for parcellation unit </span>
<span class="sd">    scans : string (int)</span>
<span class="sd">        total no of scans in the input data</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="k">as</span> <span class="nn">nib</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span> 
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">aff</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>    
        <span class="n">scans</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="n">datmask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">template</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s1">&#39;Error in loading images for graphs. Error: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">exc</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid Shape Error. mask and data file have&#39;</span>\
                        <span class="s1">&#39;different shape please check the voxel size of the two files&#39;</span><span class="p">)</span>

    <span class="c1">#check for parcellation</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
    <span class="c1">#extract timeseries</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="nb">print</span> <span class="s2">&quot;sorted nodes&quot;</span><span class="p">,</span> <span class="n">nodes</span>

        <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node_array</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">datmask</span><span class="p">]</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">node_array</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">avg</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">timeseries</span><span class="p">,</span> <span class="n">avg</span><span class="p">))</span>
            <span class="n">final_mask</span>  <span class="o">=</span> <span class="n">datmask</span>
        <span class="c1">#template_type is 1 for parcellation</span>
        <span class="n">template_type</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#template_type is 0 for mask</span>
        <span class="n">template_type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">final_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">datmask</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">final_mask</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">timeseries</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">final_mask</span><span class="p">,</span> <span class="n">template_type</span><span class="p">,</span> <span class="n">scans</span></div>


<span class="c1"># Function to calculate centrality using a correlation threshold </span>
<div class="viewcode-block" id="get_centrality_by_rvalue"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_by_rvalue">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">method_option</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">block_size</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree/eigenvector centrality and lFCD</span>
<span class="sd">    via correlation (r-value) threshold</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts_normd : ndarray (float)</span>
<span class="sd">        timeseries of shape (ntpts x nvoxs) that is normalized; i.e. the data </span>
<span class="sd">        is demeaned and divided by its L2-norm</span>
<span class="sd">    template : ndarray</span>
<span class="sd">        three dimensional array with non-zero elements corresponding to the</span>
<span class="sd">        indices at which the lFCD metric is analyzed</span>
<span class="sd">    method_option : integer</span>
<span class="sd">        0 - degree centrality calculation, </span>
<span class="sd">        1 - eigenvector centrality calculation, </span>
<span class="sd">        2 - lFCD calculation</span>
<span class="sd">    threshold : a float</span>
<span class="sd">        threshold (as correlation r) value</span>
<span class="sd">    block_size : an integer</span>
<span class="sd">        the number of rows (voxels) to compute timeseries correlation over</span>
<span class="sd">        at any one time</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list (string, ndarray)</span>
<span class="sd">        list of (string,ndarray) elements corresponding to:</span>
<span class="sd">        string - the name of the metric</span>
<span class="sd">        ndarray - the array of values to be mapped for that metric</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Import packages</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">from</span> <span class="nn">nipype</span> <span class="k">import</span> <span class="n">logging</span>

    <span class="kn">from</span> <span class="nn">CPAC.network_centrality.utils</span> <span class="k">import</span> <span class="n">cluster_data</span>
    <span class="kn">import</span> <span class="nn">CPAC.network_centrality.core</span> <span class="k">as</span> <span class="nn">core</span>

    <span class="c1"># Init variables</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;workflow&#39;</span><span class="p">)</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nvoxs</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Init degree centrality outputs</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span>
        <span class="c1"># Init output map</span>
        <span class="n">degree_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;degree_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">degree_binarize</span><span class="p">))</span>
        <span class="c1"># Init output map</span>
        <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>
    <span class="c1"># Init eigenvector centrality outputs</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
        <span class="n">r_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Init output map</span>
        <span class="n">eigen_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;eigenvector_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">eigen_binarize</span><span class="p">))</span>
        <span class="c1"># Init output map</span>
        <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>
    <span class="c1"># Init lFCD outputs</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;lfcd&#39;</span><span class="p">:</span>
        <span class="c1"># Init output map</span>
        <span class="n">lfcd_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;lfcd_binarize&#39;</span><span class="p">,</span> <span class="n">lfcd_binarize</span><span class="p">))</span>
        <span class="c1"># Init output map</span>
        <span class="n">lfcd_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;lfcd_weighted&#39;</span><span class="p">,</span> <span class="n">lfcd_weighted</span><span class="p">))</span>

    <span class="c1"># Prepare to loop through and calculate correlation matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">block_size</span>
    <span class="n">block_no</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># Run as long as our last row index is &lt;= nvoxs</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">nvoxs</span><span class="p">:</span>
        <span class="c1"># First, compute block of correlation matrix</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;running block </span><span class="si">%d</span><span class="s1">: rows </span><span class="si">%d</span><span class="s1"> thru </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">block_no</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ts_normd</span><span class="p">)</span>

        <span class="c1"># Degree centrality calculation</span>
        <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">degree_centrality</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;binarize&#39;</span><span class="p">,</span> 
                              <span class="n">out</span><span class="o">=</span><span class="n">degree_binarize</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">])</span>
            <span class="n">core</span><span class="o">.</span><span class="n">degree_centrality</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> 
                              <span class="n">out</span><span class="o">=</span><span class="n">degree_weighted</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">])</span>

        <span class="c1"># Eigenvector centrality - append global corr. matrix</span>
        <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
            <span class="n">r_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmat_block</span>

        <span class="c1"># lFCD - perform lFCD algorithm</span>
        <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;lfcd&#39;</span><span class="p">:</span>
            <span class="n">xyz_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
            <span class="n">krange</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;...iterating through seeds in block - lfcd&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">krange</span><span class="p">):</span>
                <span class="n">corr_seed</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">cluster_data</span><span class="p">(</span><span class="n">corr_seed</span><span class="p">,</span><span class="n">r_value</span><span class="p">,</span><span class="n">xyz_a</span><span class="p">)</span>
                <span class="n">seed_label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
                <span class="c1"># Binarized lFCD</span>
                <span class="k">if</span> <span class="n">seed_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">lfcd_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">seed_label</span><span class="p">)</span>
                    <span class="n">lfcd_wght</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">corr_seed</span><span class="o">*</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">seed_label</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lfcd_bin</span> <span class="o">=</span> <span class="n">lfcd_wght</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">lfcd_binarize</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfcd_bin</span>
                <span class="n">lfcd_weighted</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfcd_wght</span>

        <span class="c1"># Delete block of corr matrix and increment indices</span>
        <span class="k">del</span> <span class="n">rmat_block</span>

        <span class="c1"># Move next block start point up to last block finish point</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c1"># If we finished at nvoxs last time, break the loop</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Else, if our next block runs over nvoxs, limit it to nvoxs</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nvoxs</span>
        <span class="c1"># Else, just increment end of next block by block_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="n">block_size</span>
        <span class="c1"># Increment block number</span>
        <span class="n">block_no</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Correct for self-correlation in degree centrality</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degree_binarize</span><span class="p">)</span>
        <span class="n">degree_binarize</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree_binarize</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degree_weighted</span><span class="p">)</span>
        <span class="n">degree_weighted</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree_weighted</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Perform eigenvector measures</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;...calculating binarize eigenvector&#39;</span><span class="p">)</span>
        <span class="c1"># Have to deepcopy the r_matrix because thresh and sum overwrites</span>
        <span class="c1"># its values via pass-by-reference</span>
        <span class="n">eigen_binarize</span><span class="p">[:]</span> <span class="o">=</span> \
            <span class="n">core</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">),</span> <span class="n">r_value</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;binarize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;...calculating weighted eigenvector&#39;</span><span class="p">)</span>
        <span class="n">eigen_weighted</span><span class="p">[:]</span> <span class="o">=</span> \
            <span class="n">core</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">r_matrix</span>

    <span class="c1"># Return list of outputs</span>
    <span class="k">return</span> <span class="n">out_list</span></div>


<span class="c1"># Function to calculate centrality with a sparsity threhold</span>
<div class="viewcode-block" id="get_centrality_by_sparsity"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_by_sparsity">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_by_sparsity</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> <span class="n">method_option</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">block_size</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree/eigenvector centrality via sparsity threshold</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts_normd : ndarray</span>
<span class="sd">        timeseries of shape (ntpts x nvoxs) that is normalized; i.e. the data </span>
<span class="sd">        is demeaned and divided by its L2-norm</span>
<span class="sd">    method_option : integer</span>
<span class="sd">        0 - degree centrality calculation, </span>
<span class="sd">        1 - eigenvector centrality calculation, </span>
<span class="sd">        2 - lFCD calculation</span>
<span class="sd">    threshold : a float</span>
<span class="sd">        sparsity_threshold value</span>
<span class="sd">    block_size : an integer</span>
<span class="sd">        the number of rows (voxels) to compute timeseries correlation over</span>
<span class="sd">        at any one time</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list (string, ndarray)</span>
<span class="sd">        list of (string,ndarray) elements corresponding to:</span>
<span class="sd">        string - the name of the metric</span>
<span class="sd">        ndarray - the array of values to be mapped for that metric</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Import packages</span>
    <span class="kn">import</span> <span class="nn">copy</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
    <span class="kn">from</span> <span class="nn">nipype</span> <span class="k">import</span> <span class="n">logging</span>

    <span class="kn">import</span> <span class="nn">CPAC.network_centrality.core</span> <span class="k">as</span> <span class="nn">core</span>

    <span class="c1"># Init variables</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;workflow&#39;</span><span class="p">)</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nvoxs</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Init degree centrality outputs</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span>
        <span class="n">degree_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;degree_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">degree_binarize</span><span class="p">))</span>
        <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>

    <span class="c1"># Init eigenvector centrality outputs</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
        <span class="n">r_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Init output map</span>
        <span class="n">eigen_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;eigenvector_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">eigen_binarize</span><span class="p">))</span>
        <span class="c1"># Init output map</span>
        <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>

    <span class="c1"># Get the number of connections to keep</span>
    <span class="n">sparse_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">nvoxs</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">nvoxs</span><span class="p">)</span><span class="o">*</span><span class="n">threshold</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="c1"># Prepare to loop through and calculate correlation matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">block_size</span>
    <span class="n">block_no</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">r_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Init wij list</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">wij_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span><span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                                    <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">),</span>
                                    <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)])</span>
    <span class="c1"># Form the initial blockwise mask (to only grab upper triangle of data)</span>
    <span class="n">block_triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">block_size</span><span class="p">,</span><span class="n">block_size</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">block_rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">block_size</span><span class="p">,</span><span class="n">nvoxs</span><span class="o">-</span><span class="n">block_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">block_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">block_triu</span><span class="p">,</span><span class="n">block_rect</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Delete matrices to save memory</span>
    <span class="k">del</span> <span class="n">block_triu</span><span class="p">,</span> <span class="n">block_rect</span>
    <span class="c1"># Calculate correlations step - prune connections for degree</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nvoxs</span><span class="p">:</span>
        <span class="c1"># First, compute block of correlation matrix</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;running block </span><span class="si">%d</span><span class="s1">: rows </span><span class="si">%d</span><span class="s1"> thru </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">block_no</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Calculate wij over entire matrix by block</span>
        <span class="c1"># Do this for both deg and eig, more efficient way to compute r_value</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                            <span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:])</span>
        <span class="c1"># Shrink block_mask down on every iteration after the first block</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">block_mask</span> <span class="o">=</span> <span class="n">block_mask</span><span class="p">[:,:</span><span class="o">-</span><span class="n">block_size</span><span class="p">]</span>

        <span class="c1"># Get elements as an array</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">block_mask</span><span class="p">]</span>
        <span class="n">thr_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmat_block</span> <span class="o">&gt;=</span> <span class="n">r_value</span><span class="p">)</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">thr_idx</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;number of passing correlations is </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">))</span>

        <span class="c1"># Add global offset to indicies</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">block_mask</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">thr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">thr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>

        <span class="c1"># Free some memory</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">thr_idx</span>
        <span class="n">w_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span><span class="n">rmat_block</span><span class="p">])</span>
        <span class="n">i_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">j_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f2</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="c1"># Free some memory</span>
        <span class="k">del</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">rmat_block</span>
        <span class="c1"># Grab indices and weights that pass and combine into list</span>
        <span class="n">wij_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span><span class="n">w_global</span><span class="p">,</span><span class="n">i_global</span><span class="p">,</span><span class="n">j_global</span><span class="p">])</span>
        <span class="c1"># Free some memory</span>
        <span class="k">del</span> <span class="n">w_global</span><span class="p">,</span> <span class="n">i_global</span><span class="p">,</span> <span class="n">j_global</span>

        <span class="c1"># Pass these into the global set and sort (ascending) by correlation</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;sorting list...&#39;</span><span class="p">)</span>
        <span class="n">wij_global</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># And trim list if it&#39;s greater than the number of connections we want</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wij_global</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sparse_num</span><span class="p">:</span>
            <span class="n">wij_global</span> <span class="o">=</span> <span class="n">wij_global</span><span class="p">[</span><span class="o">-</span><span class="n">sparse_num</span><span class="p">:]</span>
        <span class="n">r_value</span> <span class="o">=</span> <span class="n">wij_global</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If we&#39;re doing eigen, store block into full matrix</span>
        <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
            <span class="n">r_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ts_normd</span><span class="p">)</span>

        <span class="c1"># Move next block start point up to last block finish point</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c1"># If we finished at nvoxs last time, break the loop</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Else, if our next block runs over nvoxs, limit it to nvoxs</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nvoxs</span>
        <span class="c1"># Else, just increment end of next block by block_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="n">block_size</span>
        <span class="c1"># Increment block number</span>
        <span class="n">block_no</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Calculate centrality step</span>
    <span class="c1"># Degree - use ijw list to create a sparse matrix</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span><span class="p">:</span>
        <span class="c1"># Create sparse (symmetric) matrix of all correlations that survived</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;creating sparse matrix&#39;</span><span class="p">)</span>
        <span class="c1"># Extract the weights and indices from the global list</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f2</span>
        <span class="k">del</span> <span class="n">wij_global</span>
        <span class="c1"># Create sparse correlation matrix (upper tri) from wij&#39;s</span>
        <span class="n">Rsp</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">w</span><span class="p">,(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">))</span>
        <span class="n">Rsp</span> <span class="o">=</span> <span class="n">Rsp</span> <span class="o">+</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># And compute degree centrality on compressed row matrix</span>
        <span class="n">Rcsr</span> <span class="o">=</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">Rsp</span>
        <span class="n">degree_binarize</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">Rcsr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">degree_weighted</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Rcsr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">Rcsr</span>

    <span class="c1"># Eigenvector - compute the r value from entire matrix</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">wij_global</span>
        <span class="c1"># Finally compute centrality using full matrix and r_value</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;...calculating binarize eigenvector&#39;</span><span class="p">)</span>
        <span class="n">eigen_binarize</span><span class="p">[:]</span> <span class="o">=</span> \
            <span class="n">core</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">),</span> <span class="n">r_value</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;binarize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;...calculating weighted eigenvector&#39;</span><span class="p">)</span>
        <span class="n">eigen_weighted</span><span class="p">[:]</span> <span class="o">=</span> \
            <span class="n">core</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">r_matrix</span>

    <span class="c1"># Return list of outputs</span>
    <span class="k">return</span> <span class="n">out_list</span></div>


<span class="c1"># Function to calculated a quick centrality measure</span>
<div class="viewcode-block" id="get_centrality_fast"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_fast">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_fast</span><span class="p">(</span><span class="n">timeseries</span><span class="p">,</span>
                        <span class="n">method_options</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree and eigen vector centrality. </span>
<span class="sd">    Relative to `get_centrality_opt`, it runs fast by not directly computing </span>
<span class="sd">    the correlation matrix. As a consequence, there are several differences/</span>
<span class="sd">    limitations from the standard approach:</span>
<span class="sd">    </span>
<span class="sd">    1. Cannot specify a correlation threshold</span>
<span class="sd">    2. As a consequence, the weighted dense matrix centrality is computed</span>
<span class="sd">    3. No memory limit is specified since it is assumed to be ok</span>
<span class="sd">    </span>
<span class="sd">    Note that the approach doesn&#39;t directly calculate the complete correlation</span>
<span class="sd">    matrix.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timeseries_data : numpy array</span>
<span class="sd">        timeseries of the input subject</span>
<span class="sd">    method_options : string (list of boolean)</span>
<span class="sd">        list of two booleans for binarize and weighted options respectively</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : string (list of tuples)</span>
<span class="sd">        list of tuple containing output name to be used to store nifti image</span>
<span class="sd">        for centrality and centrality matrix. this will only be weighted since</span>
<span class="sd">        the fast approaches are limited to this type of output.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># Import packages</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality</span> <span class="k">import</span> <span class="n">fast_degree_centrality</span><span class="p">,</span>\
                                        <span class="n">fast_eigenvector_centrality</span>
    <span class="kn">from</span> <span class="nn">CPAC.cwas.subdist</span> <span class="k">import</span> <span class="n">norm_cols</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">out_list</span>    <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nvoxs</span>       <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ntpts</span>       <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># It&#39;s assumed that there is enough memory</span>
        <span class="c1"># So a block size isn&#39;t set here</span>
        
        <span class="n">calc_degree</span>  <span class="o">=</span> <span class="n">method_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">calc_eigen</span>   <span class="o">=</span> <span class="n">method_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="nb">print</span> <span class="s2">&quot;Normalize Time-series&quot;</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">norm_cols</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="nb">print</span> <span class="s2">&quot;Computing centrality across </span><span class="si">%i</span><span class="s2"> voxels&quot;</span> <span class="o">%</span> <span class="n">nvoxs</span>
        
        <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;...calculating degree&quot;</span>
            <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">fast_degree_centrality</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s2">&quot;...calculating eigen&quot;</span>
            <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">fast_eigenvector_centrality</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">out_list</span>   
    
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> 
        <span class="nb">print</span> <span class="s2">&quot;Error in calcuating centrality&quot;</span>
        <span class="k">raise</span></div>


<span class="c1"># Main centrality function utilized by the centrality workflow</span>
<div class="viewcode-block" id="calc_centrality"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.calc_centrality">[docs]</a><span class="k">def</span> <span class="nf">calc_centrality</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">method_option</span><span class="p">,</span> <span class="n">threshold_option</span><span class="p">,</span>
                    <span class="n">threshold</span><span class="p">,</span> <span class="n">allocated_memory</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Function to calculate centrality and map them to a nifti file</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in_file : string (nifti file)</span>
<span class="sd">        path to subject data file</span>
<span class="sd">    template : string (nifti file)</span>
<span class="sd">        path to mask/parcellation unit</span>
<span class="sd">    method_option : string</span>
<span class="sd">        accepted values are &#39;degree centrality&#39;, &#39;eigenvector centrality&#39;, and</span>
<span class="sd">        &#39;lfcd&#39;</span>
<span class="sd">    threshold_option : string</span>
<span class="sd">        accepted values are: &#39;significance&#39;, &#39;sparsity&#39;, and &#39;correlation&#39;</span>
<span class="sd">    threshold : float</span>
<span class="sd">        pvalue/sparsity_threshold/threshold value</span>
<span class="sd">    allocated_memory : string</span>
<span class="sd">        amount of memory allocated to degree centrality</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list</span>
<span class="sd">        list containing out mapped centrality images</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Import packages</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality</span> <span class="k">import</span> <span class="n">load</span><span class="p">,</span>\
                                        <span class="n">get_centrality_by_rvalue</span><span class="p">,</span>\
                                        <span class="n">get_centrality_by_sparsity</span><span class="p">,</span>\
                                        <span class="n">get_centrality_fast</span><span class="p">,</span>\
                                        <span class="n">map_centrality_matrix</span><span class="p">,</span>\
                                        <span class="n">calc_blocksize</span><span class="p">,</span>\
                                        <span class="n">convert_pvalue_to_r</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality.utils</span> <span class="k">import</span> <span class="n">check_centrality_params</span>
    <span class="kn">from</span> <span class="nn">CPAC.cwas.subdist</span> <span class="k">import</span> <span class="n">norm_cols</span>

    <span class="c1"># First check input parameters and get proper formatted method/thr options</span>
    <span class="n">method_option</span><span class="p">,</span> <span class="n">threshold_option</span> <span class="o">=</span> \
        <span class="n">check_centrality_params</span><span class="p">(</span><span class="n">method_option</span><span class="p">,</span> <span class="n">threshold_option</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="c1"># Init variables</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ts</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t_type</span><span class="p">,</span> <span class="n">scans</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>

    <span class="c1"># If we&#39;re doing degree sparsity</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;degree&#39;</span> <span class="ow">and</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="s1">&#39;sparsity&#39;</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">sparsity_thresh</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
    <span class="c1"># Otherwise</span>
    <span class="k">elif</span> <span class="n">method_option</span> <span class="o">==</span> <span class="s1">&#39;eigenvector&#39;</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">include_full_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Otherwise, compute blocksize with regards to available memory</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">include_full_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># Normalize the timeseries for easy dot-product correlation calc.</span>
    <span class="n">ts_normd</span> <span class="o">=</span> <span class="n">norm_cols</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># P-value threshold centrality</span>
    <span class="k">if</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="s1">&#39;significance&#39;</span><span class="p">:</span>
        <span class="n">r_value</span> <span class="o">=</span> <span class="n">convert_pvalue_to_r</span><span class="p">(</span><span class="n">in_file</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">two_tailed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span>
                                                     <span class="n">mask</span><span class="p">,</span>
                                                     <span class="n">method_option</span><span class="p">,</span>
                                                     <span class="n">r_value</span><span class="p">,</span>
                                                     <span class="n">block_size</span><span class="p">)</span>
    <span class="c1"># Sparsity threshold</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="s1">&#39;sparsity&#39;</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_sparsity</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span>
                                                       <span class="n">method_option</span><span class="p">,</span>
                                                       <span class="n">threshold</span><span class="p">,</span>
                                                       <span class="n">block_size</span><span class="p">)</span>
    <span class="c1"># R-value threshold centrality</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="s1">&#39;correlation&#39;</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span>
                                                     <span class="n">mask</span><span class="p">,</span>
                                                     <span class="n">method_option</span><span class="p">,</span>
                                                     <span class="n">threshold</span><span class="p">,</span>
                                                     <span class="n">block_size</span><span class="p">)</span>
    <span class="c1"># For fast approach (no thresholding)</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_fast</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">method_option</span><span class="p">)</span>
    <span class="c1"># Otherwise, incorrect input for threshold_option</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s1">&#39;Threshold option: </span><span class="si">%s</span><span class="s1"> not supported for network centrality &#39;</span>\
                  <span class="s1">&#39;measure: </span><span class="si">%s</span><span class="s1">; fix this in the pipeline config&#39;</span>\
                  <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold_option</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">method_option</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
 
    <span class="c1"># Map the arrays back to images</span>
    <span class="k">for</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">centrality_matrix</span><span class="p">:</span>
        <span class="n">centrality_image</span> <span class="o">=</span> <span class="n">map_centrality_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t_type</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centrality_image</span><span class="p">)</span>

    <span class="c1"># Finally return</span>
    <span class="k">return</span> <span class="n">out_list</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/cpac_logo_vertical.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">C-PAC 1.3.0 Beta documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, C-PAC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19224662-10"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-19224662-10');
    </script>

  </body>
</html>