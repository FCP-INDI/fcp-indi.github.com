<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CPAC.network_centrality.resting_state_centrality &mdash; C-PAC 0.3.9 Alpha documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.9 Alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="C-PAC 0.3.9 Alpha documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">C-PAC 0.3.9 Alpha documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for CPAC.network_centrality.resting_state_centrality</h1><div class="highlight"><pre>
<span class="c"># Import packages</span>
<span class="kn">import</span> <span class="nn">nipype.pipeline.engine</span> <span class="kn">as</span> <span class="nn">pe</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.utility</span> <span class="kn">as</span> <span class="nn">util</span>
<span class="c"># Import CPAC functions</span>
<span class="kn">from</span> <span class="nn">CPAC.network_centrality</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">CPAC.network_centrality.core</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c"># Function to create the network centrality workflow</span>
<div class="viewcode-block" id="create_resting_state_graphs"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.create_resting_state_graphs">[docs]</a><span class="k">def</span> <span class="nf">create_resting_state_graphs</span><span class="p">(</span><span class="n">allocated_memory</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
                                <span class="n">wf_name</span> <span class="o">=</span> <span class="s">&#39;resting_state_graph&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Workflow to calculate degree and eigenvector centrality as well as </span>
<span class="sd">    local functional connectivity density (lfcd) measures for the </span>
<span class="sd">    resting state data.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    generate_graph : boolean</span>
<span class="sd">        when true the workflow plots the adjacency matrix graph </span>
<span class="sd">        and converts the adjacency matrix into compress sparse </span>
<span class="sd">        matrix and stores it in a .mat file. By default its False</span>
<span class="sd">    wf_name : string</span>
<span class="sd">        name of the workflow</span>
<span class="sd">        </span>
<span class="sd">    Returns </span>
<span class="sd">    -------</span>
<span class="sd">    wf : workflow object</span>
<span class="sd">        resting state graph workflow object</span>
<span class="sd">          </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">    `Source &lt;https://github.com/FCP-INDI/C-PAC/blob/master/CPAC/network_centrality/resting_state_centrality.py&gt;`_</span>
<span class="sd">    </span>
<span class="sd">    Workflow Inputs::</span>
<span class="sd">    </span>
<span class="sd">        inputspec.subject: string (nifti file)</span>
<span class="sd">            path to resting state input data for which centrality measure is to be calculated</span>
<span class="sd">            </span>
<span class="sd">        inputspec.template : string (existing nifti file)</span>
<span class="sd">            path to mask/parcellation unit </span>
<span class="sd">        </span>
<span class="sd">        inputspec.method_option: string (int)</span>
<span class="sd">            0 for degree centrality, 1 for eigenvector centrality, 2 for lFCD</span>
<span class="sd">        </span>
<span class="sd">        inputspec.threshold: string (float)</span>
<span class="sd">            pvalue/sparsity_threshold/threshold value</span>
<span class="sd">        </span>
<span class="sd">        inputspec.threshold_option: string (int)</span>
<span class="sd">            threshold options:  0 for probability p_value, 1 for sparsity threshold, any other for threshold value</span>
<span class="sd">           </span>
<span class="sd">        centrality_options.weight_options : string (list of boolean)</span>
<span class="sd">            list of two booleans for binarize and weighted options respectively</span>
<span class="sd">        </span>
<span class="sd">        centrality_options.method_options : string (list of boolean)</span>
<span class="sd">            list of two booleans for Degree and Eigenvector centrality method options respectively</span>
<span class="sd">        </span>
<span class="sd">    Workflow Outputs::</span>
<span class="sd">    </span>
<span class="sd">        outputspec.centrality_outputs : string (list of nifti files)</span>
<span class="sd">            path to list of centrality outputs for binarized or/and weighted and</span>
<span class="sd">            degree or/and eigen_vector </span>
<span class="sd">        </span>
<span class="sd">        outputspec.threshold_matrix : string (numpy file)</span>
<span class="sd">            path to file containing thresholded correlation matrix</span>
<span class="sd">        </span>
<span class="sd">        outputspec.correlation_matrix : string (numpy file)</span>
<span class="sd">            path to file containing correlation matrix</span>
<span class="sd">        </span>
<span class="sd">        outputspec.graph_outputs : string (mat and png files)</span>
<span class="sd">            path to matlab compatible sparse adjacency matrix files </span>
<span class="sd">            and adjacency graph images </span>
<span class="sd">    </span>
<span class="sd">    Order of commands:</span>
<span class="sd">    </span>
<span class="sd">    - load the data and template, based on template type (parcellation unit ar mask)</span>
<span class="sd">      extract timeseries</span>
<span class="sd">    </span>
<span class="sd">    - Calculate the correlation matrix for the image data for each voxel in the mask or node</span>
<span class="sd">      in the parcellation unit</span>
<span class="sd">    </span>
<span class="sd">    - Based on threshold option (p_value or sparsity_threshold), calculate the threshold value</span>
<span class="sd">    </span>
<span class="sd">    - Threshold the correlation matrix</span>
<span class="sd">     </span>
<span class="sd">    - Based on weight options for edges in the network (binarize or weighted), calculate Degree </span>
<span class="sd">      or Vector Based centrality measures</span>
<span class="sd">     </span>
<span class="sd">    </span>
<span class="sd">    High Level Workflow Graph:</span>
<span class="sd">    </span>
<span class="sd">    .. image:: ../images/resting_state_centrality.dot.png</span>
<span class="sd">       :width: 1000</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Detailed Workflow Graph:</span>
<span class="sd">    </span>
<span class="sd">    .. image:: ../images/resting_state_centrality_detailed.dot.png</span>
<span class="sd">       :width: 1000</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import resting_state_centrality as graph</span>
<span class="sd">    &gt;&gt;&gt; wflow = graph.create_resting_state_graphs()</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.centrality_options.method_options=[True, True]</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.centrality_options.weight_options=[True, True]</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.subject = &#39;/home/work/data/rest_mc_MNI_TR_3mm.nii.gz&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.template = &#39;/home/work/data/mask_3mm.nii.gz&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.threshold_option = 1</span>
<span class="sd">    &gt;&gt;&gt; wflow.inputs.inputspec.threshold = 0.0744</span>
<span class="sd">    &gt;&gt;&gt; wflow.base_dir = &#39;graph_working_directory&#39;</span>
<span class="sd">    &gt;&gt;&gt; wflow.run()</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Instantiate workflow with input name</span>
    <span class="n">wf</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">wf_name</span><span class="p">)</span>
    
    <span class="c"># Instantiate inputspec node</span>
    <span class="n">inputspec</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;subject&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;template&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;method_option&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;threshold_option&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;threshold&#39;</span><span class="p">,</span>
                                                       <span class="s">&#39;weight_options&#39;</span><span class="p">]),</span>
                        <span class="n">name</span><span class="o">=</span><span class="s">&#39;inputspec&#39;</span><span class="p">)</span>
    
    <span class="c"># Instantiate calculate_centrality main function node</span>
    <span class="n">calculate_centrality</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">input_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;datafile&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;template&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;method_option&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;threshold_option&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;threshold&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;weight_options&#39;</span><span class="p">,</span>
                                                                <span class="s">&#39;allocated_memory&#39;</span><span class="p">],</span>
                                                 <span class="n">output_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;out_list&#39;</span><span class="p">],</span>
                                                 <span class="n">function</span> <span class="o">=</span> <span class="n">calc_centrality</span><span class="p">),</span>
                                   <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;calculate_centrality&#39;</span><span class="p">)</span>
    
    <span class="c"># Connect inputspec node to main function node</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s">&#39;subject&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;datafile&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s">&#39;template&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;template&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s">&#39;method_option&#39;</span><span class="p">,</span>
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;method_option&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s">&#39;threshold_option&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;threshold_option&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span> <span class="s">&#39;threshold&#39;</span><span class="p">,</span> 
               <span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;threshold&#39;</span><span class="p">)</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">inputspec</span><span class="p">,</span><span class="s">&#39;weight_options&#39;</span><span class="p">,</span>
               <span class="n">calculate_centrality</span><span class="p">,</span><span class="s">&#39;weight_options&#39;</span><span class="p">)</span>
    
    <span class="c"># Specify allocated memory from workflow input to function node</span>
    <span class="n">calculate_centrality</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">allocated_memory</span> <span class="o">=</span> <span class="n">allocated_memory</span>
    
    <span class="c"># Instantiate outputspec node</span>
    <span class="n">outputspec</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;centrality_outputs&#39;</span><span class="p">,</span>
                                                        <span class="s">&#39;threshold_matrix&#39;</span><span class="p">,</span>
                                                        <span class="s">&#39;correlation_matrix&#39;</span><span class="p">,</span>
                                                        <span class="s">&#39;graph_outputs&#39;</span><span class="p">]),</span>
                         <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;outputspec&#39;</span><span class="p">)</span>
    
    <span class="c"># Connect function node output list to outputspec node</span>
    <span class="n">wf</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">calculate_centrality</span><span class="p">,</span> <span class="s">&#39;out_list&#39;</span><span class="p">,</span>
               <span class="n">outputspec</span><span class="p">,</span> <span class="s">&#39;centrality_outputs&#39;</span><span class="p">)</span>
    
    <span class="c"># Return the connected workflow</span>
    <span class="k">return</span> <span class="n">wf</span>


<span class="c"># Function to load in nifti files and extract info for centrality calculation</span></div>
<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">template</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to read data from datafile and mask/parcellation unit</span>
<span class="sd">    and store the mask data, timeseries, affine matrix, mask type</span>
<span class="sd">    and scans. The output of this method is used by all other nodes.</span>
<span class="sd">    </span>
<span class="sd">    Note that this function also will internally compute it&#39;s own </span>
<span class="sd">    brain mask by getting all voxels with non-zero variance in the</span>
<span class="sd">    timeseries.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datafile : string (nifti file)</span>
<span class="sd">        path to subject data file</span>
<span class="sd">    template : string (nifti file) or None (default: None)</span>
<span class="sd">        path to mask/parcellation unit</span>
<span class="sd">        if none, then will be mask with all 1s</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    timeseries_data : ndarray</span>
<span class="sd">        Masked timeseries of the input data. </span>
<span class="sd">    affine : ndarray</span>
<span class="sd">        Affine matrix of the input data</span>
<span class="sd">    final_mask : ndarray</span>
<span class="sd">        Mask/parcellation unit matrix</span>
<span class="sd">    template_type : string </span>
<span class="sd">        0 for mask, 1 for parcellation unit </span>
<span class="sd">    scans : string (int)</span>
<span class="sd">        total no of scans in the input data</span>
<span class="sd">        </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nib</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span> 
        
        <span class="n">data</span>    <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">aff</span>     <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>    
        <span class="n">scans</span>   <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        
        <span class="n">datmask</span>     <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">template</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mask</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span>    <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Error in loading images for graphs&quot;</span>
        <span class="k">raise</span>
    
    
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid Shape Error. mask and data file have&quot;</span>\
                        <span class="s">&quot;different shape please check the voxel size of the two files&quot;</span><span class="p">)</span>
    
    <span class="c">#check for parcellation</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
    <span class="c">#extract timeseries</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&quot;sorted nodes&quot;</span><span class="p">,</span> <span class="n">nodes</span>
        
        <span class="n">flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">node_array</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">datmask</span><span class="p">]</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">node_array</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">avg</span>
                    <span class="n">flag</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">timeseries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">timeseries</span><span class="p">,</span> <span class="n">avg</span><span class="p">))</span>
            <span class="n">final_mask</span>  <span class="o">=</span> <span class="n">datmask</span>
        <span class="c">#template_type is 1 for parcellation</span>
        <span class="n">template_type</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#template_type is 0 for mask</span>
        <span class="n">template_type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">final_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">datmask</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">final_mask</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">timeseries</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">final_mask</span><span class="p">,</span> <span class="n">template_type</span><span class="p">,</span> <span class="n">scans</span>


<span class="c"># Function to calculate centrality using a correlation threshold </span></div>
<div class="viewcode-block" id="get_centrality_by_rvalue"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_by_rvalue">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> 
                             <span class="n">template</span><span class="p">,</span> 
                             <span class="n">method_option</span><span class="p">,</span> 
                             <span class="n">weight_options</span><span class="p">,</span> 
                             <span class="n">r_value</span><span class="p">,</span> 
                             <span class="n">block_size</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree/eigenvector centrality and lFCD</span>
<span class="sd">    via correlation (r-value) threshold</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts_normd : ndarray (float)</span>
<span class="sd">        timeseries of shape (ntpts x nvoxs) that is normalized; i.e. the data </span>
<span class="sd">        is demeaned and divided by its L2-norm</span>
<span class="sd">    template : ndarray</span>
<span class="sd">        three dimensional array with non-zero elements corresponding to the</span>
<span class="sd">        indices at which the lFCD metric is analyzed</span>
<span class="sd">    method_option : integer</span>
<span class="sd">        0 - degree centrality calculation, </span>
<span class="sd">        1 - eigenvector centrality calculation, </span>
<span class="sd">        2 - lFCD calculation</span>
<span class="sd">    weight_options : list (boolean)</span>
<span class="sd">        weight_options[0] - True or False to perform binary counting</span>
<span class="sd">        weight_options[1] - True or False to perform weighted counting</span>
<span class="sd">    threshold : a float</span>
<span class="sd">        threshold (as correlation r) value</span>
<span class="sd">    block_size : an integer</span>
<span class="sd">        the number of rows (voxels) to compute timeseries correlation over</span>
<span class="sd">        at any one time</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list (string, ndarray)</span>
<span class="sd">        list of (string,ndarray) elements corresponding to:</span>
<span class="sd">        string - the name of the metric</span>
<span class="sd">        ndarray - the array of values to be mapped for that metric</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Import packages</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality.utils</span> <span class="kn">import</span> <span class="n">cluster_data</span>
    
    <span class="c"># Init variables</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nvoxs</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># ntpts = timeseries.shape[0]</span>
    <span class="n">calc_degree</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">calc_eigen</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">calc_lfcd</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c"># Select which method we&#39;re going to perform</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">calc_degree</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">calc_eigen</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">calc_lfcd</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c"># Weighting</span>
    <span class="n">out_binarize</span> <span class="o">=</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out_weighted</span> <span class="o">=</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c"># Init degree centrality outputs</span>
    <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
        <span class="c"># If binary weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">degree_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;degree_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">degree_binarize</span><span class="p">))</span>
        <span class="c"># If connection weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>
    <span class="c"># Init eigenvector centrality outputs</span>
    <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
        <span class="n">r_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c"># If binary weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">eigen_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;eigenvector_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">eigen_binarize</span><span class="p">))</span>
        <span class="c"># If connection weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>
    <span class="c"># Init lFCD outputs</span>
    <span class="k">if</span> <span class="n">calc_lfcd</span><span class="p">:</span>
        <span class="c"># If binary weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">lfcd_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;lfcd_binarize&#39;</span><span class="p">,</span> <span class="n">lfcd_binarize</span><span class="p">))</span>
        <span class="c"># If connection weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">lfcd_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;lfcd_weighted&#39;</span><span class="p">,</span> <span class="n">lfcd_weighted</span><span class="p">))</span>
    
    <span class="c"># Prepare to loop through and calculate correlation matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">block_size</span>
    <span class="n">block_no</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c"># Run as long as our last row index is &lt;= nvoxs</span>
    <span class="k">while</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">nvoxs</span><span class="p">:</span>
        <span class="c"># First, compute block of correlation matrix</span>
        <span class="k">print</span> <span class="s">&#39;running block </span><span class="si">%d</span><span class="s">: rows </span><span class="si">%d</span><span class="s"> thru </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">block_no</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ts_normd</span><span class="p">)</span>
        
        <span class="c"># Degree centrality calculation</span>
        <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">degree_centrality</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;binarize&#39;</span><span class="p">,</span> 
                                  <span class="n">out</span><span class="o">=</span><span class="n">degree_binarize</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">degree_centrality</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;weighted&#39;</span><span class="p">,</span> 
                                  <span class="n">out</span><span class="o">=</span><span class="n">degree_weighted</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">])</span>
        
        <span class="c"># Eigenvector centrality - append global corr. matrix</span>
        <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
            <span class="n">r_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmat_block</span>
        
        <span class="c"># lFCD - perform lFCD algorithm</span>
        <span class="k">if</span> <span class="n">calc_lfcd</span><span class="p">:</span>
            <span class="n">xyz_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
            <span class="n">krange</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">print</span> <span class="s">&#39;...iterating through seeds in block - lfcd&#39;</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">krange</span><span class="p">):</span>
                <span class="n">corr_seed</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">cluster_data</span><span class="p">(</span><span class="n">corr_seed</span><span class="p">,</span><span class="n">r_value</span><span class="p">,</span><span class="n">xyz_a</span><span class="p">)</span>
                <span class="n">seed_label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">seed_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">lfcd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">seed_label</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lfcd</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">lfcd_binarize</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfcd</span>
                <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">seed_label</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">lfcd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">corr_seed</span><span class="o">*</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">seed_label</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lfcd</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">lfcd_weighted</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfcd</span>
        
        <span class="c"># Delete block of corr matrix and increment indices</span>
        <span class="k">del</span> <span class="n">rmat_block</span>
        
        <span class="c"># Move next block start point up to last block finish point</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c"># If we finished at nvoxs last time, break the loop</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c"># Else, if our next block runs over nvoxs, limit it to nvoxs</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nvoxs</span>
        <span class="c"># Else, just increment end of next block by block_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="n">block_size</span>
        <span class="c"># Increment block number</span>
        <span class="n">block_no</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c"># Correct for self-correlation in degree centrality</span>
    <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degree_binarize</span><span class="p">)</span>
            <span class="n">degree_binarize</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree_binarize</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">degree_weighted</span><span class="p">)</span>
            <span class="n">degree_weighted</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree_weighted</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="c"># Perform eigenvector measures</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;...calculating binarize eigenvector&#39;</span>
                <span class="n">eigen_binarize</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> 
                                                           <span class="n">r_value</span><span class="p">,</span> 
                                                           <span class="n">method</span><span class="o">=</span><span class="s">&#39;binarize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;...calculating weighted eigenvector&#39;</span>
                <span class="n">eigen_weighted</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> 
                                                           <span class="n">r_value</span><span class="p">,</span> 
                                                           <span class="n">method</span><span class="o">=</span><span class="s">&#39;weighted&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">r_matrix</span>
        
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Error in calcuating eigen vector centrality&#39;</span>
        <span class="k">raise</span>
    
    <span class="c"># Return list of outputs</span>
    <span class="k">return</span> <span class="n">out_list</span>


<span class="c"># Function to calculate centrality with a sparsity threhold</span></div>
<div class="viewcode-block" id="get_centrality_by_sparsity"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_by_sparsity">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_by_sparsity</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> 
                               <span class="n">method_option</span><span class="p">,</span> 
                               <span class="n">weight_options</span><span class="p">,</span> 
                               <span class="n">threshold</span><span class="p">,</span> 
                               <span class="n">block_size</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree/eigenvector centrality via sparsity threshold</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ts_normd : ndarray</span>
<span class="sd">        timeseries of shape (ntpts x nvoxs) that is normalized; i.e. the data </span>
<span class="sd">        is demeaned and divided by its L2-norm</span>
<span class="sd">    method_option : integer</span>
<span class="sd">        0 - degree centrality calculation, </span>
<span class="sd">        1 - eigenvector centrality calculation, </span>
<span class="sd">        2 - lFCD calculation</span>
<span class="sd">    weight_options : list (boolean)</span>
<span class="sd">        weight_options[0] - True or False to perform binary counting</span>
<span class="sd">        weight_options[1] - True or False to perform weighted counting</span>
<span class="sd">    threshold : a float</span>
<span class="sd">        sparsity_threshold value</span>
<span class="sd">    block_size : an integer</span>
<span class="sd">        the number of rows (voxels) to compute timeseries correlation over</span>
<span class="sd">        at any one time</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list (string, ndarray)</span>
<span class="sd">        list of (string,ndarray) elements corresponding to:</span>
<span class="sd">        string - the name of the metric</span>
<span class="sd">        ndarray - the array of values to be mapped for that metric</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Import packages</span>
    <span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>

    <span class="c"># Init variables</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nvoxs</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c"># ntpts = timeseries.shape[0]</span>
    <span class="n">calc_degree</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">calc_eigen</span> <span class="o">=</span> <span class="bp">False</span>
    
    <span class="c"># Select which method we&#39;re going to perform</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">calc_degree</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">calc_eigen</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="c"># Weighting</span>
    <span class="n">out_binarize</span> <span class="o">=</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out_weighted</span> <span class="o">=</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c"># Init degree centrality outputs</span>
    <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
        <span class="c"># If binary weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">degree_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;degree_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">degree_binarize</span><span class="p">))</span>
        <span class="c"># If connection weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>
    
    <span class="c"># Init eigenvector centrality outputs</span>
    <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
        <span class="n">r_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c"># If binary weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="n">eigen_binarize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;eigenvector_centrality_binarize&#39;</span><span class="p">,</span> <span class="n">eigen_binarize</span><span class="p">))</span>
        <span class="c"># If connection weighting, init output map</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>
    
    <span class="c"># Get the number of connections to keep</span>
    <span class="n">sparse_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">nvoxs</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">nvoxs</span><span class="p">)</span><span class="o">*</span><span class="n">threshold</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    
    <span class="c"># Prepare to loop through and calculate correlation matrix</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">block_size</span>
    <span class="n">block_no</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">r_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c"># Init wij list</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">wij_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span><span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ts_normd</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> 
                                    <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">),</span> 
                                    <span class="n">z</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)])</span>
    <span class="c"># Form the initial blockwise mask (to only grab upper triangle of data)</span>
    <span class="n">block_triu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">block_size</span><span class="p">,</span><span class="n">block_size</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">block_rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">block_size</span><span class="p">,</span><span class="n">nvoxs</span><span class="o">-</span><span class="n">block_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">block_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">block_triu</span><span class="p">,</span><span class="n">block_rect</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># Delete matrices to save memory</span>
    <span class="k">del</span> <span class="n">block_triu</span><span class="p">,</span> <span class="n">block_rect</span>
    <span class="c"># Calculate correlations step - prune connections for degree</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nvoxs</span><span class="p">:</span>
        <span class="c"># First, compute block of correlation matrix</span>
        <span class="k">print</span> <span class="s">&#39;running block </span><span class="si">%d</span><span class="s">: rows </span><span class="si">%d</span><span class="s"> thru </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">block_no</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># Calculate wij over entire matrix by block</span>
        <span class="c"># Do this for both deg and eig, more efficient way to compute r_value</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                            <span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:])</span>
        <span class="c"># Shrink block_mask down on every iteration after the first block</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">block_mask</span> <span class="o">=</span> <span class="n">block_mask</span><span class="p">[:,:</span><span class="o">-</span><span class="n">block_size</span><span class="p">]</span>
        <span class="c"># Get elements as an array</span>
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">block_mask</span><span class="p">]</span>
        <span class="n">thr_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rmat_block</span> <span class="o">&gt;=</span> <span class="n">r_value</span><span class="p">)</span>   
        <span class="n">rmat_block</span> <span class="o">=</span> <span class="n">rmat_block</span><span class="p">[</span><span class="n">thr_idx</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&#39;number of passing correlations is </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">rmat_block</span><span class="p">)</span>
        <span class="c"># Add global offset</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">block_mask</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">thr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">thr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
        <span class="c"># Free some memory</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">thr_idx</span>
        <span class="n">w_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f0</span><span class="p">,</span><span class="n">rmat_block</span><span class="p">])</span>
        <span class="n">i_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">j_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">wij_global</span><span class="o">.</span><span class="n">f2</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="c"># Free some memory</span>
        <span class="k">del</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">rmat_block</span>
        <span class="c"># Grab indices and weights that pass and combine into list</span>
        <span class="n">wij_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">([</span><span class="n">w_global</span><span class="p">,</span><span class="n">i_global</span><span class="p">,</span><span class="n">j_global</span><span class="p">])</span>
        <span class="c"># Free some memory</span>
        <span class="k">del</span> <span class="n">w_global</span><span class="p">,</span> <span class="n">i_global</span><span class="p">,</span> <span class="n">j_global</span>
        <span class="c"># Pass these into the global set and sort (ascending) by correlation</span>
        <span class="k">print</span> <span class="s">&#39;sorting list...&#39;</span>
        <span class="n">wij_global</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c"># And trim list if it&#39;s greater than the number of connections we want</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wij_global</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sparse_num</span><span class="p">:</span>
            <span class="n">wij_global</span> <span class="o">=</span> <span class="n">wij_global</span><span class="p">[</span><span class="o">-</span><span class="n">sparse_num</span><span class="p">:]</span>
        <span class="n">r_value</span> <span class="o">=</span> <span class="n">wij_global</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c"># If we&#39;re doing eigen, store block into full matrix</span>
        <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
            <span class="n">r_matrix</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">[:,</span><span class="n">n</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ts_normd</span><span class="p">)</span>
        
        <span class="c"># Move next block start point up to last block finish point</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span>
        <span class="c"># If we finished at nvoxs last time, break the loop</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c"># Else, if our next block runs over nvoxs, limit it to nvoxs</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nvoxs</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nvoxs</span>
        <span class="c"># Else, just increment end of next block by block_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">+=</span> <span class="n">block_size</span>
        <span class="c"># Increment block number</span>
        <span class="n">block_no</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c"># Calculate centrality step</span>
    <span class="c"># Degree - use ijw list to create a sparse matrix</span>
    <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
        <span class="c"># Create sparse (symmetric) matrix of all correlations that survived</span>
        <span class="k">print</span> <span class="s">&#39;creating sparse matrix&#39;</span>
        <span class="c"># Extract the weights and indices from the global list</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f0</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">wij_global</span><span class="o">.</span><span class="n">f2</span>
        <span class="k">del</span> <span class="n">wij_global</span>
        <span class="c"># And compute degree centrality on sparse matrix</span>
        <span class="k">if</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c"># Create the sparse correlation matrix (upper triangle) from wij&#39;s</span>
            <span class="n">Rsp</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)),(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">))</span>
            <span class="c"># Make it symmetric</span>
            <span class="n">Rsp</span> <span class="o">=</span> <span class="n">Rsp</span> <span class="o">+</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Rcsr</span> <span class="o">=</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="n">degree_binarize</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Rcsr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># Create the sparse correlation matrix (upper triangle) from wij&#39;s</span>
            <span class="n">Rsp</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">w</span><span class="p">,(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nvoxs</span><span class="p">,</span><span class="n">nvoxs</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
            <span class="c"># Make it symmetric</span>
            <span class="n">Rsp</span> <span class="o">=</span> <span class="n">Rsp</span> <span class="o">+</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Rcsr</span> <span class="o">=</span> <span class="n">Rsp</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
            <span class="n">degree_weighted</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Rcsr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">Rsp</span>
    
    <span class="c"># Eigenvector - compute the r value from entire matrix</span>
    <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">wij_global</span>
        <span class="c"># Finally compute centrality using full matrix and r_value</span>
        <span class="k">if</span> <span class="n">out_binarize</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;...calculating binarize eigenvector&#39;</span>
            <span class="n">eigen_binarize</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> 
                                                       <span class="n">method</span><span class="o">=</span><span class="s">&#39;binarize&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">out_weighted</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;...calculating weighted eigenvector&#39;</span>
            <span class="n">eigen_weighted</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">r_matrix</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> 
                                                       <span class="n">method</span><span class="o">=</span><span class="s">&#39;weighted&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">r_matrix</span>
    
    <span class="c"># Return list of outputs</span>
    <span class="k">return</span> <span class="n">out_list</span>


<span class="c"># Function to calculated a quick centrality measure</span></div>
<div class="viewcode-block" id="get_centrality_fast"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.get_centrality_fast">[docs]</a><span class="k">def</span> <span class="nf">get_centrality_fast</span><span class="p">(</span><span class="n">timeseries</span><span class="p">,</span>
                        <span class="n">method_options</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate degree and eigen vector centrality. </span>
<span class="sd">    Relative to `get_centrality_opt`, it runs fast by not directly computing </span>
<span class="sd">    the correlation matrix. As a consequence, there are several differences/</span>
<span class="sd">    limitations from the standard approach:</span>
<span class="sd">    </span>
<span class="sd">    1. Cannot specify a correlation threshold</span>
<span class="sd">    2. As a consequence, the weighted dense matrix centrality is computed</span>
<span class="sd">    3. No memory limit is specified since it is assumed to be ok</span>
<span class="sd">    </span>
<span class="sd">    Note that the approach doesn&#39;t directly calculate the complete correlation</span>
<span class="sd">    matrix.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timeseries_data : numpy array</span>
<span class="sd">        timeseries of the input subject</span>
<span class="sd">    method_options : string (list of boolean)</span>
<span class="sd">        list of two booleans for binarize and weighted options respectively</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : string (list of tuples)</span>
<span class="sd">        list of tuple containing output name to be used to store nifti image</span>
<span class="sd">        for centrality and centrality matrix. this will only be weighted since</span>
<span class="sd">        the fast approaches are limited to this type of output.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Import packages</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality</span> <span class="kn">import</span> <span class="n">fast_degree_centrality</span><span class="p">,</span>\
                                        <span class="n">fast_eigenvector_centrality</span>
    <span class="kn">from</span> <span class="nn">CPAC.cwas.subdist</span> <span class="kn">import</span> <span class="n">norm_cols</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">out_list</span>    <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nvoxs</span>       <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ntpts</span>       <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c"># It&#39;s assumed that there is enough memory</span>
        <span class="c"># So a block size isn&#39;t set here</span>
        
        <span class="n">calc_degree</span>  <span class="o">=</span> <span class="n">method_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">calc_eigen</span>   <span class="o">=</span> <span class="n">method_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">print</span> <span class="s">&quot;Normalize Time-series&quot;</span>
        <span class="n">timeseries</span> <span class="o">=</span> <span class="n">norm_cols</span><span class="p">(</span><span class="n">timeseries</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">print</span> <span class="s">&quot;Computing centrality across </span><span class="si">%i</span><span class="s"> voxels&quot;</span> <span class="o">%</span> <span class="n">nvoxs</span>
        
        <span class="k">if</span> <span class="n">calc_degree</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;...calculating degree&quot;</span>
            <span class="n">degree_weighted</span> <span class="o">=</span> <span class="n">fast_degree_centrality</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;degree_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">degree_weighted</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">calc_eigen</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;...calculating eigen&quot;</span>
            <span class="n">eigen_weighted</span> <span class="o">=</span> <span class="n">fast_eigenvector_centrality</span><span class="p">(</span><span class="n">timeseries</span><span class="p">)</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;eigenvector_centrality_weighted&#39;</span><span class="p">,</span> <span class="n">eigen_weighted</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">out_list</span>   
    
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> 
        <span class="k">print</span> <span class="s">&quot;Error in calcuating centrality&quot;</span>
        <span class="k">raise</span>


<span class="c"># Main centrality function utilized by the centrality workflow</span></div>
<div class="viewcode-block" id="calc_centrality"><a class="viewcode-back" href="../../../workflows/network_centrality.html#CPAC.network_centrality.calc_centrality">[docs]</a><span class="k">def</span> <span class="nf">calc_centrality</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span>
                    <span class="n">template</span><span class="p">,</span>
                    <span class="n">method_option</span><span class="p">,</span>
                    <span class="n">threshold_option</span><span class="p">,</span>
                    <span class="n">threshold</span><span class="p">,</span>
                    <span class="n">weight_options</span><span class="p">,</span>
                    <span class="n">allocated_memory</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Method to calculate centrality and map them to a nifti file</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    datafile : string (nifti file)</span>
<span class="sd">        path to subject data file</span>
<span class="sd">    template : string (nifti file)</span>
<span class="sd">        path to mask/parcellation unit</span>
<span class="sd">    method_option : integer</span>
<span class="sd">        0 - degree centrality calculation, 1 - eigenvector centrality calculation, 2 - lFCD calculation</span>
<span class="sd">    threshold_option : an integer</span>
<span class="sd">        0 for probability p_value, 1 for sparsity threshold, </span>
<span class="sd">        2 for actual threshold value, and 3 for no threshold and fast approach</span>
<span class="sd">    threshold : a float</span>
<span class="sd">        pvalue/sparsity_threshold/threshold value</span>
<span class="sd">    weight_options : list (boolean)</span>
<span class="sd">        list of booleans, where, weight_options[0] corresponds to binary counting </span>
<span class="sd">        and weight_options[1] corresponds to weighted counting (e.g. [True,False]) </span>
<span class="sd">    allocated_memory : string</span>
<span class="sd">        amount of memory allocated to degree centrality</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out_list : list</span>
<span class="sd">        list containing out mapped centrality images</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Import packages</span>
    <span class="kn">from</span> <span class="nn">CPAC.network_centrality</span> <span class="kn">import</span> <span class="n">load</span><span class="p">,</span>\
                                        <span class="n">get_centrality_by_rvalue</span><span class="p">,</span>\
                                        <span class="n">get_centrality_by_sparsity</span><span class="p">,</span>\
                                        <span class="n">get_centrality_fast</span><span class="p">,</span>\
                                        <span class="n">map_centrality_matrix</span><span class="p">,</span>\
                                        <span class="n">calc_blocksize</span><span class="p">,</span>\
                                        <span class="n">convert_pvalue_to_r</span>
    <span class="kn">from</span> <span class="nn">CPAC.cwas.subdist</span> <span class="kn">import</span> <span class="n">norm_cols</span>
    
    <span class="c"># Check for input errors</span>
    <span class="k">if</span> <span class="n">weight_options</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Invalid values in weight options&quot;</span> \
                        <span class="s">&quot;At least one True value is required&quot;</span><span class="p">)</span>
    <span class="c"># If it&#39;s sparsity thresholding, check for (0,1]</span>
    <span class="k">if</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Threshold value must be a positive number&#39;</span>\
                            <span class="s">&#39;greater than 0 and less than or equal to 1.&#39;</span>\
                            <span class="s">&#39;</span><span class="se">\n</span><span class="s">Currently it is set at </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">threshold_option</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;lFCD must use correlation-type thresholding.&#39;</span>\
                         <span class="s">&#39;Check the pipline configuration has this setting&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
    
    <span class="c"># Init variables</span>
    <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ts</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t_type</span><span class="p">,</span> <span class="n">scans</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
    
    <span class="c"># If we&#39;re doing eigenvectory centrality, need entire correlation matrix</span>
    <span class="k">if</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">sparsity_thresh</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">include_full_matrix</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># Otherwise, compute blocksize with regards to available memory</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">calc_blocksize</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">memory_allocated</span><span class="o">=</span><span class="n">allocated_memory</span><span class="p">,</span>
                                    <span class="n">include_full_matrix</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="c"># Normalize the timeseries for easy dot-product correlation calc.</span>
    <span class="n">ts_normd</span> <span class="o">=</span> <span class="n">norm_cols</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    <span class="c"># P-value threshold centrality</span>
    <span class="k">if</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r_value</span> <span class="o">=</span> <span class="n">convert_pvalue_to_r</span><span class="p">(</span><span class="n">scans</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> 
                                                     <span class="n">mask</span><span class="p">,</span> 
                                                     <span class="n">method_option</span><span class="p">,</span> 
                                                     <span class="n">weight_options</span><span class="p">,</span> 
                                                     <span class="n">r_value</span><span class="p">,</span> 
                                                     <span class="n">block_size</span><span class="p">)</span>
    <span class="c"># Sparsity threshold</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_sparsity</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> 
                                                       <span class="n">method_option</span><span class="p">,</span> 
                                                       <span class="n">weight_options</span><span class="p">,</span> 
                                                       <span class="n">threshold</span><span class="p">,</span> 
                                                       <span class="n">block_size</span><span class="p">)</span>
    <span class="c"># R-value threshold centrality</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_by_rvalue</span><span class="p">(</span><span class="n">ts_normd</span><span class="p">,</span> 
                                                     <span class="n">mask</span><span class="p">,</span> 
                                                     <span class="n">method_option</span><span class="p">,</span> 
                                                     <span class="n">weight_options</span><span class="p">,</span> 
                                                     <span class="n">threshold</span><span class="p">,</span> 
                                                     <span class="n">block_size</span><span class="p">)</span>
    <span class="c"># For fast approach (no thresholding)</span>
    <span class="k">elif</span> <span class="n">threshold_option</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">centrality_matrix</span> <span class="o">=</span> <span class="n">get_centrality_fast</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">method_option</span><span class="p">)</span>
    <span class="c"># Otherwise, incorrect input for threshold_option</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;Option must be between 0-3 and not </span><span class="si">%s</span><span class="s">, check your &#39;</span>\
                        <span class="s">&#39;pipeline config file&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">threshold_option</span><span class="p">))</span>
    
    <span class="c"># Print timing info</span>
    <span class="k">print</span> <span class="s">&#39;Timing:&#39;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
 
    <span class="c"># Map the arrays back to images</span>
    <span class="k">for</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">centrality_matrix</span><span class="p">:</span>
        <span class="n">centrality_image</span> <span class="o">=</span> <span class="n">map_centrality_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">aff</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t_type</span><span class="p">)</span>
        <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centrality_image</span><span class="p">)</span>
    
    <span class="c"># Finally return</span>
    <span class="k">return</span> <span class="n">out_list</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">C-PAC 0.3.9 Alpha documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, C-PAC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>